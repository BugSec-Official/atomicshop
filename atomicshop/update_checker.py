# v1.0.2 - 21.03.2023 13:50
import os
from pathlib import Path
import functools

from . import hashing, file_io, jsons
from .print_api import print_api


def handle_input_file(function_name):
    @functools.wraps(function_name)
    def wrapper(self, **kwargs):
        # If 'input_file_directory' was specified, this means that 'input file' will be created for storing
        # content of the function to compare.
        if self.input_file_directory:
            # Create full file path from file name that was generated by previous function or specified by the user.
            self._generate_input_file_path()

            # If 'object_content' is not yet probed, meaning that this is the first cycle and since the directory
            # path was specified for the input file, we will read the input file to get the previously probed content.
            # Also, if the user specified 'input_file_write_only=False' that he doesn't want to only write the
            # input file, we will read the file in the beginning of each cycle.
            if not self.object_content or not self.input_file_write_only:
                try:
                    if self.save_as == 'txt':
                        self.object_content = file_io.read_file(self.input_file_path, stderr=False, **kwargs)
                    elif self.save_as == 'json':
                        self.object_content = jsons.read_json_file(self.input_file_path, stderr=False, **kwargs)
                except FileNotFoundError as except_object:
                    message = f"Input File [{Path(except_object.filename).name}] doesn't exist - Will create new one."
                    print_api(message, color='yellow', **kwargs)
                    pass

        try:
            # Try getting the content of current function.
            current_content = function_name(self)
        except FileNotFoundError as except_object:
            raise FileNotFoundError(f"File to check for update doesn't exist [{except_object.filename}]")

        # If known content differs from just taken content.
        result = None
        if self.object_content != current_content:
            # If known content is not empty (if it is, it means it is the first iteration, and we don't have the input
            # file, so we don't need to update the 'result', since there is nothing to compare yet).
            if self.object_content or (not self.object_content and self.return_first_cycle):
                result = {
                    'old': self.object_content,
                    'updated': current_content,
                    'type': self.object_type
                }

            # Make known content the current, since it is updated.
            self.object_content = current_content
            # If 'input_file_directory' was specified by the user, it means that we will use the input file to save
            # our known content there for next iterations to compare.
            if self.input_file_directory:
                if self.save_as == 'txt':
                    file_io.write_file(self.object_content, self.input_file_path, **kwargs)
                elif self.save_as == 'json':
                    jsons.write_json_file(
                        self.object_content, self.input_file_path, use_default_indent=True, **kwargs)

        return result

    return wrapper


class UpdateChecker:
    def __init__(
            self,
            input_file_directory: str = str(), input_file_name: str = str(),
            add_object_type_to_input_filename: bool = False, input_file_write_only: bool = True,
            return_first_cycle: bool = True):
        """
        :param input_file_directory: string, full directory path for storing input files for current state of objects,
            to check later if this state isn't updated. If this variable is left empty, all the content will be saved
            in memory and input file will not be used.
            If the file is not specified, the update of an object will be checked
            only during the time that the script is running. Meaning, each time the script starts from beginning
            it will measure the object from the start as the script didn't know what it was before running.
            The problem? If you want to check that a program updated and the computer restarted, you will not
            know about that if the input file wasn't written. Since, the script will not know what happened before
            restart and what hash value the file had before the update.
        :param input_file_name: string, of file name to save as. If file name wasn't specified, we will
            generate one.
        :param add_object_type_to_input_filename: boolean,
            True: 'self.object_type' will be added before 'self.input_file_name'.
            False: 'self.input_file_name' will be used as is.
        :param input_file_write_only: boolean,
            True: read only once on script start and only write to input file each time there is an update, while
                reading the variable from the memory each cycle.
            False: read each check cycle from the file.
        :param return_first_cycle: boolean, the first cycle is the one that compares acquired content to empty
            content, since there was no content previously. Meaning, that content was updated, but it's not
            always interesting - the content didn't really update, it just didn't exist.

            True: return updated dictionary on first cycle. This is the default.
            False: don't return updated dictionary on first cycle.
        """

        self.input_file_directory: str = input_file_directory
        self.input_file_name: str = input_file_name

        # All the options must be specified if you want to use input file to save current state data.
        if self.input_file_directory or self.input_file_name:
            if not self.input_file_directory:
                raise ValueError("[input_file_directory] option wasn't specified.")
            elif not self.input_file_name:
                raise ValueError("[input_file_name] option wasn't specified.")

        self.input_file_path: str = str()
        self.input_file_write_only: bool = input_file_write_only
        self.add_object_type_to_input_filename: bool = add_object_type_to_input_filename
        self.return_first_cycle: bool = return_first_cycle

        # 'object' can be full file path of a file or registry path for value.
        self.object = None
        # 'file_hash' / 'registry_value'
        self.object_type: str = str()
        # the hash of a file itself or registry value.
        self.object_content = None
        # The format the file will be saved as (not used as extension): txt, json.
        self.save_as: str = str()

    def _generate_input_file_path(self):
        if self.add_object_type_to_input_filename:
            self.input_file_path = f'{self.input_file_directory}{os.sep}{self.object_type}_{self.input_file_name}'
        else:
            self.input_file_path = f'{self.input_file_directory}{os.sep}{self.input_file_name}'

    def check_file_hash(self, file_path: str, **kwargs):
        """
        The function will check file content for change by hashing it and comparing the hash.

        :param file_path: string, full file path to a file to check for content change.
        """

        @handle_input_file
        def hash_file(self, **kwargs):
            # Inner function that is decorated by 'handle_input_file' function.
            return hashing.file_hash(self.object, 'sha256')

        self.object = file_path
        self.object_type = 'FileHash'
        self.save_as = 'txt'

        # Each function need to initialize the object content to the proper type it will use.
        if not self.object_content:
            self.object_content = str()

        # Don't forget that this is decorated by 'handle_input_file'.
        return hash_file(self, **kwargs)

    def check_list_of_dicts(self, list_of_dicts: list, **kwargs):
        """
        The function will check list of dicts for change, while saving it to combined json file.

        :param list_of_dicts: list, that will contain dict objects.
        """

        @handle_input_file
        def return_object(self, **kwargs):
            # Inner function that is decorated by 'handle_input_file' function.
            # We need to reinitialize list, so we don't pass the same instance to itself in the future.
            return list(self.object)

        self.object = list_of_dicts
        self.object_type = 'ListOfDicts'
        self.save_as = 'json'

        # Each function need to initialize the object content to the proper type it will use.
        if not self.object_content:
            self.object_content = list()

        # Don't forget that this is decorated by 'handle_input_file'.
        return return_object(self, **kwargs)
